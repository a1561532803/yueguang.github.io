<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS——Multi-column Layout 布局</title>
      <link href="/posts/35894.html"/>
      <url>/posts/35894.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSS——Multi-column-Layout-布局"><a href="#CSS——Multi-column-Layout-布局" class="headerlink" title="CSS——Multi-column Layout 布局"></a>CSS——Multi-column Layout 布局</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    CSS3引入新的Multi-column Layout模型，从底层支持多栏布局。</p><h2 id="标签解释"><a href="#标签解释" class="headerlink" title="标签解释"></a>标签解释</h2><ul><li><article> 标签- 定义外部的内容，外部内容可以是来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。（w3s）</article></li><li><p>CSS3中的article容器</p><ul><li><p>拓展：</p><ul><li>section：当然既然可以用section,那这部分内容就一定也可以使用section,section中文就是：节，部分的意思，文章的目录，大纲最适合使用。section里一般都会有一个标题。</li></ul></li><li><p>article：是一个特殊的 section 标签，它比 section 具有更明确的语义, 它代表一个独立的、完整的相关内容块。一段内容已具备section中的标题时，如果这段内容可以独立存在表达一个意思，讲一个故事，说清楚一件事，那么这段内容就可以用article。article里面一般可以包括header,section,footer标签。</p></li></ul></li></ul><h2 id="示例1：新闻分栏"><a href="#示例1：新闻分栏" class="headerlink" title="示例1：新闻分栏"></a>示例1：新闻分栏</h2><ul><li><p>准备</p><ul><li>最初样式<img src="https://api2.mubu.com/v3/document_image/32587cf7-b94e-432e-a123-de2a954ccd7c-2637220.jpg" alt="img"></li></ul></li><li><p>开始布局</p><ul><li><p>给article容器设置一个<code>column-count</code>属性，表示显示多少列<img src="https://gitee.com/zygxhp/picture/raw/master/img/image-20210706233243049.png" alt="image-20210706233243049"></p><ul><li><p>或者使用<code>column-width</code>来设置每列固定的宽度，让浏览器根据空间显示多少列（根据浏览器宽度自动控制显示多少列）<img src="https://api2.mubu.com/v3/document_image/71fd24ae-e477-4b10-a42c-6d8a468079ab-2637220.jpg" alt="img"></p></li><li><p>也可以使用<code>columns</code>这个简写形式，它可以同时指定列数和列宽，但是只有列数是起作用的，如以下这个属性，最后还是只能显示三列，和columns的结果一样</p></li><li><p><img src="https://gitee.com/zygxhp/picture/raw/master/img/79299e7b-cc5f-4c54-a754-fee99b4cbce8-2637220.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/e1736872-fefd-4027-9075-3d588403d0ee-2637220.jpg" alt="img"></p></li></ul></li><li><p>使用<code>column-gap</code>设置列边距，这样每列之间的间隔就会变大<img src="https://api2.mubu.com/v3/document_image/2544f37e-d291-4472-8467-20042d863a29-2637220.jpg" alt="img"></p></li><li><p>使用<code>column-rule</code>设置分隔线，这里代码是</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">column-rule</span><span class="token punctuation">:</span>2px solid <span class="token function">hsl</span><span class="token punctuation">(</span>0deg<span class="token punctuation">,</span> 0%<span class="token punctuation">,</span> 30%<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/zygxhp/picture/raw/master/img/image-20210706233350725.png" alt="image-20210706233350725"></p><ul><li><p><code>column-rule</code> 属性规定了列与列之间的直线，也称“规则”</p></li><li><p>注：hsl()函数表示色相、饱和度、亮度</p><ul><li><p>色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。</p></li><li><p>饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0-100% 的数值。</p></li><li><p>亮度（L），取 0-100%，增加亮度，颜色会向白色变化；减少亮度，颜色会向黑色变化</p></li></ul></li></ul></li><li><p>设置一个高度与<code>column-fill</code>属性，这样当第一列填满之后才开始填第二列<img src="https://api2.mubu.com/v3/document_image/1cd4b700-fb56-496f-9a41-1531a84548b2-2637220.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/34359d7d-0ddd-4ede-a6da-07ff6ef9522d-2637220.jpg" alt="img"></p></li><li><p>文本中有h2标题，可以设置一个跨列显示（设置背景色是为了显眼）<img src="https://gitee.com/zygxhp/picture/raw/master/img/image-20210706233447429.png" alt="image-20210706233447429"></p><ul><li><p>column-span 属性规定元素应横跨多少列。</p></li><li><p><code>column-span:all</code> 横跨所有列。</p></li></ul></li></ul></li></ul><h2 id="示例2：古书排版"><a href="#示例2：古书排版" class="headerlink" title="示例2：古书排版"></a>示例2：古书排版</h2><ul><li><p>演示诗词：李白–古朗月行</p><ul><li><p>小时不识月，呼作白玉盘。</p></li><li><p>又疑瑶台镜，飞在青云端。</p></li><li><p>仙人垂两足，桂树何团团。</p></li><li><p>白兔捣药成，问言与谁餐?</p></li><li><p>蟾蜍蚀圆影，大明夜已残。</p></li><li><p>羿昔落九乌，天人清且安。</p></li><li><p>阴精此沦惑，去去不足观。</p></li><li><p>忧来其如何？凄怆摧心肝。</p></li></ul></li><li><p>代码<img src="https://api2.mubu.com/v3/document_image/49f66715-d8ae-4b60-9c3a-cf9384991b84-2637220.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/7fce1f43-776d-47ea-9527-a4c712f23ff4-2637220.jpg" alt="img"></p></li><li><p>效果<img src="https://api2.mubu.com/v3/document_image/00598970-a834-4a41-8222-4a46ba0b3b65-2637220.jpg" alt="img"></p></li></ul><p>批注</p><ul><li><p>每一栏的宽度必须控制在一个字左右，所以这里对于容器的宽度有严格的要求（即column-rule，指定列之间的规则：宽度，样式和颜色）</p></li><li><p>通过<code>word-wrap: break-word</code>属性使中文的标点符号换行；</p></li><li><p><code>direction: rtl</code> 把文本方向设置为“从右向左”。</p><ul><li><p>direction 属性规定文本的方向 / 书写方向。</p></li><li><p>ltr：默认。文本方向从左到右。</p></li><li><p>rtl：文本方向从右到左。</p></li><li><p>inherit：规定应该从父元素继承 direction 属性的值。</p></li></ul></li></ul><p>示例1学习与代码来源：<a href="https://github.com/zxuqian/html-css-examples/blob/master/40-multi-column-layout/index.html">https://github.com/zxuqian/html-css-examples/blob/master/40-multi-column-layout/index.html</a></p><p>示例2学习自官方文档，css代码如下</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.demo</span> <span class="token punctuation">{</span>        <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>        <span class="token property">margin</span><span class="token punctuation">:</span> 100px auto<span class="token punctuation">;</span>        <span class="token property">columns</span><span class="token punctuation">:</span> 10<span class="token punctuation">;</span>        <span class="token property">column-rule</span><span class="token punctuation">:</span> 1px dashed <span class="token function">rgb</span><span class="token punctuation">(</span>213<span class="token punctuation">,</span>213<span class="token punctuation">,</span>213<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token property">direction</span><span class="token punctuation">:</span> rtl<span class="token punctuation">;</span>        <span class="token property">word-wrap</span><span class="token punctuation">:</span> break-word<span class="token punctuation">;</span>        <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> web开发 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker复习——实训篇</title>
      <link href="/posts/26626.html"/>
      <url>/posts/26626.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker安装："><a href="#Docker安装：" class="headerlink" title="Docker安装："></a>Docker安装：</h2><blockquote><p>此题必会(本地yum源法)：<strong>使用xserver1节点，自行配置YUM源，安装docker服务（(需要用到的包为xserver1节点/root目录下的Docker.tar.gz)。安装完服务后，将registry_latest.tar上传到xserver1节点中并配置为私有仓库。要求启动registry容器时，将内部保存文件的目录映射到外部的/opt)/registry目录，将内部的5000端口映射到外部5000端口。依次将启动registry容器的命令及返回结果、执行docker info命令的返回结果以文本形式提交到答题框。</strong></p></blockquote><p>答：</p><p>1、先配置yum源：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># cd /etc/yum.repos.d/</span><span class="token punctuation">[</span>root@xserver1 yum.repos.d<span class="token punctuation">]</span><span class="token comment">#mv * /media/  #将目录底下的源全部移走</span><span class="token punctuation">[</span>root@xserver1 yum.repos.d<span class="token punctuation">]</span><span class="token comment"># vi local.repo</span><span class="token punctuation">[</span>docker<span class="token punctuation">]</span><span class="token assign-left variable">name</span><span class="token operator">=</span>docker<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>file:///root/Docker<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span><span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入完成之后按键盘上的ESC键退出插入模式，最后一行没有出现– INSERT –就可以输入：<code>wq</code> （保存且退出）</p><p>2、回到家目录，解压家目录下的Docker.tar.gz包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 yum.repos.d<span class="token punctuation">]</span><span class="token comment"># cd       #回到家目录</span><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># ll            #查看是否有Docker.tar.gz包</span>``<span class="token variable"><span class="token variable">`</span><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># tar -zxvf Docker.tar.gz   #解压包</span><span class="token variable">`</span></span>``<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、下载docker包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># yum -y install docker-ce</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>4、开启docker服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># systemctl start docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5、上传registry_latest.tar包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># cd images/</span><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># ll       #查看该目录下有无registry_latest.tar包</span><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker load -i registry_latest.tar</span>d9ff549177a9: Loading layer  <span class="token number">4</span>.671MB/4.671MBf641ef7a37ad: Loading layer  <span class="token number">1</span>.587MB/1.587MBd5974ddb5a45: Loading layer  <span class="token number">20</span>.08MB/20.08MB5bbc5831d696: Loading layer  <span class="token number">3</span>.584kB/3.584kB73d61bf022fd: Loading layer  <span class="token number">2</span>.048kB/2.048kBLoaded image: registry:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6、启动registry容器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker run -itd -v /opt/registry:/var/lib/registry -p 5000:5000 --name registry registry:latest</span>2931309e69d0346e7a094362133f8fff588b90914e59350f9d861dbfe2e2c711<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>7、编写daemon.json文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># vi /etc/docker/daemon.json    #添加以下内容</span><span class="token punctuation">{</span><span class="token string">"insecure-registries"</span>:<span class="token punctuation">[</span><span class="token string">"192.168.100.144:5000"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入完成之后按键盘上的ESC键退出插入模式，最后一行没有出现– INSERT –就可以输入：<code>wq</code> （保存且退出）</p><p>8、重启docker服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># systemctl restart docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>9、查看容器的相关信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker info</span>Containers: <span class="token number">1</span> Running: <span class="token number">0</span> Paused: <span class="token number">0</span> Stopped: <span class="token number">1</span>Images: <span class="token number">1</span>Server Version: <span class="token number">18.09</span>.6Storage Driver: devicemapper Pool Name: docker-253:0-67650867-pool Pool Blocksize: <span class="token number">65</span>.54kB Base Device Size: <span class="token number">10</span>.74GB Backing Filesystem: xfs Udev Sync Supported: <span class="token boolean">true</span> Data file: /dev/loop0 Metadata file: /dev/loop1 Data loop file: /var/lib/docker/devicemapper/devicemapper/data Metadata loop file: /var/lib/docker/devicemapper/devicemapper/metadata Data Space Used: <span class="token number">59</span>.44MB Data Space Total: <span class="token number">107</span>.4GB Data Space Available: <span class="token number">27</span>.74GB Metadata Space Used: <span class="token number">692</span>.2kB Metadata Space Total: <span class="token number">2</span>.147GB Metadata Space Available: <span class="token number">2</span>.147GB Thin Pool Minimum Free Space: <span class="token number">10</span>.74GB Deferred Removal Enabled: <span class="token boolean">true</span> Deferred Deletion Enabled: <span class="token boolean">true</span> Deferred Deleted Device Count: <span class="token number">0</span> Library Version: <span class="token number">1.02</span>.107-RHEL7 <span class="token punctuation">(</span><span class="token number">2015</span>-10-14<span class="token punctuation">)</span>Logging Driver: json-fileCgroup Driver: cgroupfsPlugins: Volume: <span class="token builtin class-name">local</span> Network: bridge <span class="token function">host</span> macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file <span class="token builtin class-name">local</span> logentries splunk syslogSwarm: inactiveRuntimes: runcDefault Runtime: runcInit Binary: docker-initcontainerd version: b34a5c8af56e510852c35414db4c1f4fa6172339runc version: 3e425f80a8c931f88e6d94a8c831b9d5aa481657init version: fec3683Security Options: seccomp Profile: defaultKernel Version: <span class="token number">3.10</span>.0-327.el7.x86_64Operating System: CentOS Linux <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>OSType: linuxArchitecture: x86_64CPUs: <span class="token number">2</span>Total Memory: <span class="token number">3</span>.688GiBName: xserver1ID: 42CR:4TGY:VUJ3:HR5L:3Z2J:ICYF:4MDN:NNT5:D5UE:K6R5:FIDR:3WJBDocker Root Dir: /var/lib/dockerDebug Mode <span class="token punctuation">(</span>client<span class="token punctuation">)</span>: <span class="token boolean">false</span>Debug Mode <span class="token punctuation">(</span>server<span class="token punctuation">)</span>: <span class="token boolean">false</span>Registry: https://index.docker.io/v1/Labels:Experimental: <span class="token boolean">false</span>Insecure Registries: <span class="token number">192.168</span>.100.144:5000 <span class="token number">127.0</span>.0.0/8Live Restore Enabled: <span class="token boolean">false</span>Product License: Community Engine <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker运维："><a href="#Docker运维：" class="headerlink" title="Docker运维："></a>Docker运维：</h2><blockquote><p><strong>使用xserver1节点，上传nginx_latest.tar到xserver1节点中，然后将该镜像打标签，上传至私有仓库。使用xserver2节点，自行安装docker服务，配置xserver2节点使用xserver1的私有仓库，配置完毕后，在xserver2节点拉取nginx_latest.tar镜像。最后将在xserver2上执行docker images命令返回的结果以文本形式提交到答题框。</strong></p><p>可在一个节点上完成</p></blockquote><p>1、先安装docker，同上一题的操作一样（之后不再解释这一步），配置yum源：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># cd /etc/yum.repos.d/</span><span class="token punctuation">[</span>root@xserver1 yum.repos.d<span class="token punctuation">]</span><span class="token comment">#mv * /media/  #将目录底下的源全部移走</span><span class="token punctuation">[</span>root@xserver1 yum.repos.d<span class="token punctuation">]</span><span class="token comment"># vi local.repo</span><span class="token punctuation">[</span>docker<span class="token punctuation">]</span><span class="token assign-left variable">name</span><span class="token operator">=</span>docker<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>file:///root/Docker<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span><span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入完成之后按键盘上的ESC键退出插入模式，最后一行没有出现– INSERT –后输入：<code>wq</code> （保存且退出）</p><p>2、回到家目录，解压家目录下的Docker.tar.gz包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 yum.repos.d<span class="token punctuation">]</span><span class="token comment"># cd       #回到家目录</span><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># ll            #查看是否有Docker.tar.gz包</span><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># tar -zxvf Docker.tar.gz   #解压包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、下载docker包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># yum -y install docker-ce</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、开启docker服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># systemctl start docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>5、上传nginx_latest.tar包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker load -i nginx_latest.tar </span>b67d19e65ef6: Loading layer  <span class="token number">72</span>.5MB/72.5MB6eaad811af02: Loading layer  <span class="token number">57</span>.54MB/57.54MBa89b8f05da3a: Loading layer  <span class="token number">3</span>.584kB/3.584kBLoaded image: nginx:latest <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6、打标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker tag nginx:latest 192.168.100.144:5000/nginx</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>7、查看镜像信息（命令：docker images）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker images</span>REPOSITORY          TAG         IMAGE ID       CREATED       SIZE<span class="token number">192.168</span>.100.144:5000/nginx  latest        540a289bab6c     <span class="token number">19</span> months ago    126MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="部署Swarm集群："><a href="#部署Swarm集群：" class="headerlink" title="部署Swarm集群："></a><em>部署Swarm集群：</em></h2><blockquote><p>使用xserver1、xserver2节点，自行配置好网络，安装好docker-ce。<strong>部署Swarm集群，并安装Portainer图形化管理工具，部署完成后，使用浏览器登录ip:9000界面，进入Swarm控制台。将curl swarm ip:9000返回的结果以文本形式提交到答题框。</strong></p></blockquote><p>1、用本地yum源下载docker（上述题有方法，不赘述）</p><p>2、下载docker包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># yum -y install docker-ce</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 3、开启docker服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># systemctl start docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4、安装portainer图形化管理工具：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker load -i portainer_portainer_latest.tar </span>dd4969f97241: Loading layer   278kB/278kB8b156c0136c9: Loading layer  <span class="token number">80</span>.32MB/80.32MBLoaded image ID: sha256:4cda95efb0e455c3044d727988c36c5947a4287f77db96e799199b349b3d523c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6、启动容器：</p><p>先查看镜像id（docker images）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker images</span>REPOSITORY          TAG         IMAGE ID       CREATED       SIZE<span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>            <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        4cda95efb0e4     <span class="token number">20</span> months ago    <span class="token number">80</span>.6MB <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动容器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker run -d -p 9000:9000 4cda95efb0e4</span>b7c9cb0f2576964c486d4dc6d47a4eba0d30c008c10a2889bfe1ffb5386421a7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看容器状态：   容器状态时create，就需要启动容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker ps -a</span>CONTAINER ID     IMAGE        COMMAND          CREATED       STATUS            PORTS        NAMESb7c9cb0f2576     4cda95efb0e4     <span class="token string">"/portainer"</span>       <span class="token number">23</span> seconds ago    Created  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动容器（docker start 容器id）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker start b7c9cb0f2576</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <u>注意：如遇到这种启动失败的情况，请重启docker服务，命令（<code>systemctl restart docker</code>）:</u></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> <span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># docker start b7c9cb0f2576 </span>Error response from daemon: driver failed programming external connectivity on endpoint reverent_nobel <span class="token punctuation">(</span>47ffbf28f68d851c9488e4cd95c1f8a1b6949c705f5e082c1a4740e38760368d<span class="token punctuation">)</span>:  <span class="token punctuation">(</span>iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d <span class="token number">0</span>/0 --dport <span class="token number">9000</span> -j DNAT --to-destination <span class="token number">172.17</span>.0.2:9000 <span class="token operator">!</span> -i docker0: iptables: No chain/target/match by that name. <span class="token punctuation">(</span>exit status <span class="token number">1</span><span class="token punctuation">))</span>Error: failed to start containers: b7c9cb0f2576<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7、使用curl命令返回IP：9000的结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment"># curl 192.168.100.144:9000</span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>html <span class="token assign-left variable">lang</span><span class="token operator">=</span><span class="token string">"en"</span> ng-app<span class="token operator">=</span><span class="token string">"portainer"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>meta <span class="token assign-left variable">charset</span><span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Portainer<span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>meta <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"description"</span> <span class="token assign-left variable">content</span><span class="token operator">=</span><span class="token string">""</span><span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>meta <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"author"</span> <span class="token assign-left variable">content</span><span class="token operator">=</span><span class="token string">"Portainer.io"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>div <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">"row"</span> <span class="token assign-left variable">style</span><span class="token operator">=</span><span class="token string">"text-align: center"</span><span class="token operator">&gt;</span>  Loading Portainer<span class="token punctuation">..</span>.  <span class="token operator">&lt;</span>i <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">"fa fa-cog fa-spin"</span> <span class="token assign-left variable">style</span><span class="token operator">=</span><span class="token string">"margin-left: 5px"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/i<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker管理："><a href="#Docker管理：" class="headerlink" title="Docker管理："></a>Docker管理：</h2><blockquote><p><em><strong>假设当前存在docker镜像mysqlatest，将该镜像上传至本地，然后将该镜像推送至本地仓库（假设仓库地址为192.168.100.100:5000)，从私有仓库中拉取mariadbv10.3.18镜像。运行mysql镜像，要求将内部3306端口映射到外部的13306端口，提供交互接口，后台运行，容器名为xmysql。最后将mysql镜像和创建的容器删除。依次提交操作命令。</strong></em></p></blockquote><p><code>docker load -i mysql:latest</code></p><p><code>docker push 192.168.100.100:5000/mysql:latest</code></p><p><code>docker pull mariadb:v10.3.18</code></p><p><code>docker run -itd –-name xmysql -p 13306:3306 mysql:latest /bin/bash</code></p><p><code>docker rmi mysql:latest</code></p><p><code>docker rm -f xmysql</code></p><h2 id="Docker管理2："><a href="#Docker管理2：" class="headerlink" title="Docker管理2："></a>Docker管理2：</h2><blockquote><p><em><strong>*假设当前存在docker镜像tomcatlatest，现在将tomcat镜像导出，导出名称为tomcat_images.tar，放在/media目录下,将以上操作命令填入答题框。*</strong></em></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 images<span class="token punctuation">]</span><span class="token comment">#docker save tomcat:latest &gt; /media/tomcat_images.tar</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Dockerfile编写："><a href="#Dockerfile编写：" class="headerlink" title="Dockerfile编写："></a>Dockerfile编写：</h2><blockquote><p><em><strong>*使用xserver1节点，新建httpd目录，然后编写Dockerfile文件，要求如下∶1)使用centos:latest镜像作为基础镜像;2)作者为xiandian ; 3)Dockerfile要求删除镜像的yum源，使用当前系统的local.repo源文件;4)安装http服务;5)暴露80端口。编写完毕后，构建的镜像名字叫httpd.v1.0的镜像。完成后将Dockerfile文件和镜像列表信息以文本形式提交到答题框。*</strong></em></p></blockquote><p>1、创建httpd目录,并进入目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># mkdir httpd</span><span class="token punctuation">[</span>root@xserver1 ~<span class="token punctuation">]</span><span class="token comment"># cd httpd/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2、在目录中创建并编写Dockerfile文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 httpd<span class="token punctuation">]</span><span class="token comment"># vi Dockerfile</span> FROM centos:latestMAINTAINER xiandianRUN <span class="token function">rm</span> -rf /etc/yum.repos.d/*ADD local.repo /etc/yum.repos.d/RUN yum -y <span class="token function">install</span> httpdEXPOSE <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入完成之后按键盘上的ESC键退出插入模式，最后一行没有出现– INSERT –就可以输入：<code>wq</code> （保存且退出）</p><p>3、先在当前目录httpd中创建一个名为local.repo文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 httpd<span class="token punctuation">]</span><span class="token comment"># touch local.repo</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、 将RUN yum -y install httpd注释掉：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 httpd<span class="token punctuation">]</span><span class="token comment"># vi Dockerfile </span> FROM centos:latestMAINTAINER xiandianRUN <span class="token function">rm</span> -rf /etc/yum.repos.d/*ADD local.repo /etc/yum.repos.d/<span class="token punctuation">\</span>#RUN yum -y <span class="token function">install</span> httpdEXPOSE <span class="token number">80</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#输入完成之后按键盘上的ESC键退出插入模式，最后一行没有出现– INSERT –就可以输入：<code>wq</code> （保存且退出）</p><p>因为centos:latest这个镜像是centos8最新版本，我们电脑的linux版本是centos7，可以用一下命令查看linux版本，如果版本是最新版本，就不需要注释掉RUN yum -y install httpd，直接进入构建镜像步骤：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 httpd<span class="token punctuation">]</span><span class="token comment"># cat /etc/redhat-release </span>CentOS Linux release <span class="token number">7.2</span>.1511 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>5、构建镜像：</p><p>如遇到这种<strong>报错</strong>提示，启动docker服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 httpd<span class="token punctuation">]</span><span class="token comment"># docker build -t httpd:v1.0 .</span>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?<span class="token punctuation">[</span>root@xserver1 httpd<span class="token punctuation">]</span><span class="token comment"># systemctl start docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出现下面两行，就算构建镜像成功：</p><p><code>Successfully built 1a549714d06f</code></p><p><code>Successfully tagged httpd:v1.0</code></p><p>6、查看镜像列表信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xserver1 httpd<span class="token punctuation">]</span><span class="token comment"># docker images</span>REPOSITORY          TAG         IMAGE ID       CREATED        SIZEhttpd             v1.0         1a549714d06f     About a minute ago  209MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker复习——简答题篇</title>
      <link href="/posts/57113.html"/>
      <url>/posts/57113.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker复习——简答篇"><a href="#docker复习——简答篇" class="headerlink" title="docker复习——简答篇"></a>docker复习——简答篇</h1><p>注：（）内容为可替换内容/详细补充</p><h2 id="基础简答题"><a href="#基础简答题" class="headerlink" title="基础简答题"></a>基础简答题</h2><h3 id="什么是docker？"><a href="#什么是docker？" class="headerlink" title="什么是docker？"></a>什么是docker？</h3><p>答：docker是一个容器平台，可以将开发的项目连同环境一起打包，上线部署。</p><h3 id="Docker与虚拟机的不同点在哪里？"><a href="#Docker与虚拟机的不同点在哪里？" class="headerlink" title="Docker与虚拟机的不同点在哪里？"></a>Docker与虚拟机的不同点在哪里？</h3><p><img src="https://gitee.com/zygxhp/picture/raw/master/img/image-20210705184026311.png" alt="image-20210705184026311"></p><p>答：</p><p>介绍：</p><p>​    docker是一个容器平台，将应用打包进docker后，启动的容器使用沙箱机制，相互隔离，互不影响。</p><p>​    虚拟机是运行在操作系统中的一个虚拟系统。</p><p><strong>区别：</strong></p><p>​    1.启动时间：容器时秒级启动，虚拟机是分钟级启动。</p><p>​    2.轻量级：容器一般是m级别的大小，虚拟机时g级别的大小。</p><p>​    3.性能：容器内部的系统仅支持系统的正常运行，虚拟机则需要一套完整的系统。</p><h3 id="Docker容器有几种状态，分别是什么？"><a href="#Docker容器有几种状态，分别是什么？" class="headerlink" title="Docker容器有几种状态，分别是什么？"></a>Docker容器有几种状态，分别是什么？</h3><p><strong>答：四种状态；运行，已暂停，重新启动，退出</strong></p><p><em>拓展：docker容器的生命周期？</em></p><p>​    <em>答：一个docker容器从产生到运行部署大致分为如下三个状态：Dockerfile、Image、Contaniner。</em></p><p>​    <em>即一个镜像文件从产生、运行到停止的过程。</em></p><h3 id="写出Dockerfile中最常见四条指令，并指明含义？"><a href="#写出Dockerfile中最常见四条指令，并指明含义？" class="headerlink" title="写出Dockerfile中最常见四条指令，并指明含义？"></a>写出Dockerfile中最常见四条指令，并指明含义？</h3><p> 答：</p><p>​    From 指定基础镜像</p><p>​    RUN 运行指定命令</p><p>​    CMD 容器启动时运行的命令</p><p>​    COPY 拷贝文件到镜像</p><p>​    ADD 同copy，但多了解压缩的功能</p><p>​    VOLUME 指定挂载点，容器和宿主机的目录</p><p>​    EVN 设定容器内环境变量</p><h3 id="Docker镜像特点是什么？如何自定义镜像？"><a href="#Docker镜像特点是什么？如何自定义镜像？" class="headerlink" title="Docker镜像特点是什么？如何自定义镜像？"></a>Docker镜像特点是什么？如何自定义镜像？</h3><p>答：（1）Docker镜像就<strong>是一个只读的模板</strong>，容器<strong>在启动的时</strong>候<strong>创建一层可写层</strong>作为<strong>最上层</strong></p><p>（2）方法一：使用<strong>DockerFile直接创建自定义镜像</strong>，基本步骤分别为：编写Dockerfile文件、docker build 生成镜像、docker run 创建容器运行。</p><p>方法二：使用IDEA创建自定义镜像</p><p><em>拓展：启动后，可通过日志查询命令查看是否已启动完毕且成功。</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker logs -f 镜像名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Docker-数据卷有什么作用？创建数据卷的命令是？"><a href="#Docker-数据卷有什么作用？创建数据卷的命令是？" class="headerlink" title="Docker 数据卷有什么作用？创建数据卷的命令是？"></a>Docker 数据卷有什么作用？创建数据卷的命令是？</h3><p> <strong>答：容器的持久化、容器间继承与共享数据。</strong></p><p><strong>命令：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -it -v /宿主机绝对路径目录:/容器内目录      镜像名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>详细补充：</p><p>​    Docker数据卷作用（特点）：</p><pre><code>1. 数据卷可在容器之间共享或重用数据2. 卷中的更改可以直接生效3. 数据卷中的更改不会包含在镜像的更新中4. 数据卷的生命周期一直持续到没有容器使用它为止</code></pre><p>创建数据卷的命令：</p><p>使用 -v 命令，也可以在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷</p><p>-v命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -it -v /宿主机绝对路径目录:/容器内目录      镜像名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 带权限的-v命令： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：</p><p>出于可移植和分享的考虑，<u>用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。</u></p><p>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p><p>使用file构建</p><p>重点：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">VOLUME<span class="token punctuation">[</span><span class="token string">"/dataVolumeContainer"</span>,<span class="token string">"/dataVolumeContainer2"</span>,<span class="token string">"/dataVolumeContainer3"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># volume test</span>FROM centosVOLUME <span class="token punctuation">[</span><span class="token string">"/dataVolumeContainer1"</span>,<span class="token string">"/dataVolumeContainer2"</span><span class="token punctuation">]</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"finished,--------success1"</span>CMD /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Docker仓库有哪些，它们的区别是什么？"><a href="#Docker仓库有哪些，它们的区别是什么？" class="headerlink" title="Docker仓库有哪些，它们的区别是什么？"></a>Docker仓库有哪些，它们的区别是什么？</h3><p> 答：分公有仓库与私有仓库</p><p>公有仓库：<strong>Docker Hub</strong>、时速云镜像仓库、网易云镜像服务、DaoCloud镜像市场、阿里云镜像库等</p><p> 私有仓库：用户自己在本地搭建私有Docker Register（最常用的就是registry、Harbor两种）</p><p>区别：公有仓库所有人都可以搜索和下载公共镜像，私有仓库只有私有用户才能查询和下载。</p><h3 id="什么是Docker-Swarm，其功能是什么？"><a href="#什么是Docker-Swarm，其功能是什么？" class="headerlink" title="什么是Docker Swarm，其功能是什么？"></a>什么是Docker Swarm，其功能是什么？</h3><p> 答：<strong>它是Docker的本机群集</strong>（Swarm 是docker公司原生的集群管理（编排）工具。）；<strong>它将Docker主机池转变为单个虚拟Docker主机</strong>（它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机）（把一组docker主机抽象为一个整体来管理。），Docker Swarm<strong>提供标准的Docker API</strong>，使得容器可以组成跨主机的子网网络。</p><p><em>拓展：Docker三剑客</em></p><p><em>Docker Machine、Docker Compose、Docker Swarm 并称 Docker 三剑客。</em></p><p><em>拓展：Do</em>cker swarm组成<br>    <em>Docker swarm节点类型两种：</em><br>      <em>1、manager 负责整个集群的管理，manager本身worker节点，但生产环境不推荐。manager节点一般奇数个，1、3、5</em><br>      2、worker 负责运行相应服务，即负责容器的创建。*</p><h3 id="什么是Docker-Compose，使用的步骤是什么"><a href="#什么是Docker-Compose，使用的步骤是什么" class="headerlink" title="什么是Docker Compose，使用的步骤是什么?"></a>什么是Docker Compose，使用的步骤是什么?</h3><p> 答：（1）<strong>Docker Compose是一个用来定义和运行复杂应用的Docker工具。</strong></p><p>使用Docker Compose不再需要使用shell脚本来启动容器，而使用服务编排的方式来管理容器。</p><p><strong>Docker Compose核心是通过一个YAML文件来管理多个Docker容器</strong>，接着就可以从配置中创建并启动所有服务。</p><p> （2）①定义要创建的应用，②创建容器的Dockerfile文件，③定义docker-compose脚本（创建docker-compose.yml文件，并在里面定义服务），④使用Compose构建并运行应用程序，⑤编辑compose文件以添加文件绑定挂载，⑥使用更新的compose文件重新构建和运行应用程序。</p><p> 脚本文件示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">'3'</span>services:  web:    build: <span class="token punctuation">..</span>/    ports:     - <span class="token string">"5000:5000"</span>    volumes:     - <span class="token punctuation">..</span>/src:/opt/src  redis:    image: <span class="token string">"redis:3.0.7"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个compose文件就定义了两个服务，即定义了web和redis两个容器。 </p><p>再通过volumes（卷）将主机上的项目目录（../src）挂载到容器中的/opt/src目录下，允许您即时修改代码，而无需重新构建映像。</p><p>web容器： </p><ul><li>使用当前docker-compose.yml文件所在目录的上级目录（compose_test/Dockerfile）中的Dockerfile构建映像。 </li><li>将容器上的暴露端口5000映射到主机上的端口5000。 我们使用Flask Web服务器的默认端口5000。<br>redis容器： </li><li>redis服务使用从Docker Hub提取的官方redis镜像3.0.7版本。</li></ul><p>最后一步命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Registry服务端、客户端如何配置？"><a href="#Registry服务端、客户端如何配置？" class="headerlink" title="Registry服务端、客户端如何配置？"></a>Registry服务端、客户端如何配置？</h3><p> <em>本题答案参考自<a href="https://blog.51cto.com/u_14306186/2514802">https://blog.51cto.com/u_14306186/2514802</a></em></p><p>答：准备两台docker服务器，dockerA创建registry私有仓库，dockerB做测试的客户端。</p><p>tips：本题主要记配置文件的代码</p><p>即docker A：<code>ExecStart=/usr/bin/dockerd    --insecure-registry 服务器IP地址:5000端口号</code></p><p>docker B： <code>ExecStart=/usr/bin/dockerd --insecure-registry 客户端IP地址:5000端口号</code></p><p>注：客户端一定要和服务器仓库ip一致 不然无法识别和上传 至于5000端口 应为registry默认5000端口</p><p>详细步骤：</p><p>docker A:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@dockerA ~<span class="token punctuation">]</span><span class="token comment"># docker pull registry:2              //下载registry:2的镜像</span><span class="token punctuation">[</span>root@dockerA ~<span class="token punctuation">]</span><span class="token comment"># docker run -itd --name registry --restart=always  -p 5000:5000 -v /registry:/var/lib/registry registry:2</span>//创建一个registry容器来运行registry服务；//-p：端口映射（前面是宿主机端口：后面是容器暴露的端口）；//-v：挂载目录（前面是宿主机的目录：后面的是容器的目录）自动创建宿主机的目录；//--restart<span class="token operator">=</span>always：随docker服务的启动而启动！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="https://gitee.com/zygxhp/picture/raw/master/img/image-20210705203256085.png" alt="image-20210705203256085"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@dockerA ~<span class="token punctuation">]</span><span class="token comment"># docker tag  centos:7 192.168.45.129:5000/centos:7  </span>//更改镜像名称注：私有仓库镜像的命名规则：192.168.45.129:5000/XXX（宿主机的IP:5000端口/镜像名称）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/zygxhp/picture/raw/master/img/image-20210705203355817.png" alt="image-20210705203355817"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@dockerA ~<span class="token punctuation">]</span><span class="token comment"># vim /usr/lib/systemd/system/docker.service   //修改docker主配置文件</span><span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/bin/dockerd    --insecure-registry <span class="token number">192.168</span>.45.129:5000  //修改原本的配置文件添加不安全的仓库（--insecure-registry），地址是宿主机的IP地址与5000端口<span class="token punctuation">[</span>root@dockerA ~<span class="token punctuation">]</span><span class="token comment"># systemctl daemon-reload </span><span class="token punctuation">[</span>root@dockerA ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart docker             //重新启动docker服务</span><span class="token punctuation">[</span>root@dockerA ~<span class="token punctuation">]</span><span class="token comment"># docker push  192.168.45.129:5000/centos:7</span>//将重命名后的镜像上传到registry私有仓库<span class="token punctuation">[</span>root@dockerA ~<span class="token punctuation">]</span><span class="token comment"># curl 192.168.45.129:5000/v2/_catalog             //查看私有仓库中的镜像</span><span class="token punctuation">{</span><span class="token string">"repositories"</span>:<span class="token punctuation">[</span><span class="token string">"centos"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">[</span>root@dockerA ~<span class="token punctuation">]</span><span class="token comment"># curl 192.168.45.129:5000/v2/centos/tags/list         //查看镜像的详细信息</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token builtin class-name">:</span><span class="token string">"centos"</span>,<span class="token string">"tags"</span>:<span class="token punctuation">[</span><span class="token string">"7"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>dockerB：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@dockerB ~<span class="token punctuation">]</span><span class="token comment"># vim /usr/lib/systemd/system/docker.service </span>//修改docker的主配置文件 <span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/bin/dockerd --insecure-registry <span class="token number">192.168</span>.45.129:5000//添加内容与registry一致，指定registry私有仓库服务器的IP地址及端口<span class="token punctuation">[</span>root@dockerB ~<span class="token punctuation">]</span><span class="token comment"># systemctl daemon-reload </span><span class="token punctuation">[</span>root@dockerB ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart docker            //重新启动docker服务</span><span class="token punctuation">[</span>root@dockerB ~<span class="token punctuation">]</span><span class="token comment"># curl 192.168.45.129:5000/v2/_catalog         //查看私有仓库中的镜像</span><span class="token punctuation">{</span><span class="token string">"repositories"</span>:<span class="token punctuation">[</span><span class="token string">"centos"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">[</span>root@dockerB ~<span class="token punctuation">]</span><span class="token comment"># curl 192.168.45.129:5000/v2/centos/tags/list     //查看私有仓库中的镜像</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token builtin class-name">:</span><span class="token string">"centos"</span>,<span class="token string">"tags"</span>:<span class="token punctuation">[</span><span class="token string">"7"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">[</span>root@dockerB ~<span class="token punctuation">]</span><span class="token comment"># docker pull 192.168.45.129:5000/centos:7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/zygxhp/picture/raw/master/img/image-20210705203542638.png" alt="image-20210705203542638"></p><h3 id="集群中时间同步的方式有哪两种？客户端使用什么命令查看时间是否同步成功？"><a href="#集群中时间同步的方式有哪两种？客户端使用什么命令查看时间是否同步成功？" class="headerlink" title="集群中时间同步的方式有哪两种？客户端使用什么命令查看时间是否同步成功？"></a>集群中时间同步的方式有哪两种？客户端使用什么命令查看时间是否同步成功？</h3><p>答：有chrony服务和ntp服务；chrony服务：在客户端节点执行<code>chronyc sources -v</code>，结果中包含*，则代表同步成功。如果结果中有？，则代表同步不成功，需要等待。ntp服务：执行<code>ntpstat</code>命令</p><p>NTP配置详细：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/ntp.conf           ntpdate server IP   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><em>重启ntpd服务。</em></p><p><em>跳跃同步，使用ntpdate不能开启ntpd服务</em></p><p>拓展：</p><p>搭建NTP时间服务器(服务端配置)</p><p><em>解释：自己搭建一台NTP服务器，然后其它机器同步这台NTP时间服务器上的时间，而NTP时间服务器同步公网上远程机器的时间，从而实现整套集群保持与北京时间同步。</em></p><p>安装ntp（NTP服务端的包名）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01 ~<span class="token punctuation">]</span><span class="token comment"># hostname -I</span><span class="token number">10.0</span>.0.61 <span class="token number">172.16</span>.1.61<span class="token punctuation">[</span>root@m01 ~<span class="token punctuation">]</span><span class="token comment"># yum install ntp</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动ntpd服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01 ~<span class="token punctuation">]</span><span class="token comment"># systemctl start ntpd</span><span class="token punctuation">[</span>root@m01 ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable ntpd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其它内网机器同步NTP时间服务器(172.16.1.61)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@lb01 ~<span class="token punctuation">]</span><span class="token comment"># hostname -I</span><span class="token number">172.16</span>.1.5 <span class="token punctuation">[</span>root@lb01 ~<span class="token punctuation">]</span><span class="token comment"># yum install ntpdate -y</span><span class="token punctuation">[</span>root@lb01 ~<span class="token punctuation">]</span><span class="token comment"># date -s '20081024'</span><span class="token punctuation">[</span>root@lb01 ~<span class="token punctuation">]</span><span class="token comment"># ntpdate 172.16.1.61</span><span class="token punctuation">[</span>root@lb01 ~<span class="token punctuation">]</span><span class="token comment"># date</span>Fri Oct <span class="token number">19</span> <span class="token number">10</span>:35:35 CST <span class="token number">2018</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ntpd服务只要启动，自动会在后台为这台NTP服务器同步时间(可能需要等几分钟)，不需要我们手动操作，其它机器只需同步这台NTP服务器即可。</p><p>命令：<code>ntpstat</code>，查看是否成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ntpstat</span>unsynchronised  <span class="token function">time</span> server re-starting   polling server every <span class="token number">8</span> s <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>chrony配置详细：<br>     1、 server端：<br>      （1）安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> chrony<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​      （2）修改配置文件 <code>vi /etc/chrony.conf</code><br>​            ①将原有server开头的注释掉<br>​            ②在文件最后追加以下内容<br>​                    </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">local</span> stratum <span class="token number">10</span> //不同步外部时钟源                    server master iburst//自己做时钟源                    allow all //允许所有客户端同步我这个时钟源，使用我做时钟源服务器     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（3）重启服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart chronyd  <span class="token operator">&amp;&amp;</span> systemctl <span class="token builtin class-name">enable</span> chronyd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​     2、client端<br>​         （1）安装包<code>yum install chrony</code><br>​         （2）修改配置文件 ``vi /etc/chrony.conf<code>​               ①将原有server开头的注释掉 ​               ②在文件最后追加以下内容 ​                 </code>server 10.1.0.10 iburst  //配置10.1.0.10<code>为时钟源 ​           （3）重启服务 ​                 </code>systemctl restart chronyd  &amp;&amp; systemctl enable chronyd`</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到我的个人博客</title>
      <link href="/posts/21396.html"/>
      <url>/posts/21396.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于内容"><a href="#关于内容" class="headerlink" title="关于内容"></a>关于内容</h1><p>以技术博客方向为主，记录自己踩过的坑，考前抱佛脚恶补的知识，分享前辈们的经验，收集到的资源，偶尔备份一些喜欢的句子、读书笔记、生活小技巧等等。</p><p>你可以将本站当做一个资源库来使用。</p><p>欢迎各位大佬们与我交换友链qwq。</p><h1 id="资源分享"><a href="#资源分享" class="headerlink" title="资源分享"></a>资源分享</h1><h2 id="博客搭建框架"><a href="#博客搭建框架" class="headerlink" title="博客搭建框架"></a>博客搭建框架</h2><p>hexo：</p><p>是一个基于nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen</p><p>安装简单快速、资源丰富，文档对中国朋友很友好，强推！</p><p>本站即是使用该框架搭建！<br><a href="https://hexo.io/zh-cn/">前往Hexo</a></p><p>Wordpress：</p><p>使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。</p><p>老牌建站系统，社区强大，对seo搜索引擎友好，适合DIY，静态化较差，使用的谷歌字体、头像经常被墙，访问加载速度慢，不能一键更新。</p><p><a href="https://wordpress.org/download/">前往Wordpress</a></p><p>Jekyll：</p><p>是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如discuz。<br><a href="http://jekyllcn.com/">前往Jekyll</a></p><p>Hugo：</p><p>Golang语言开发</p><p>特点：</p><p>1、完全跨平台支持，可以运行在 Mac OS X, Linux, Windows, 以及更多!</p><p>2、安装方便 Installation</p><p>3、本地调试 Usage 时通过 LiveReload 自动即时刷新页面。</p><p>4、完全的皮肤支持。</p><p>5、可以部署在任何的支持 HTTP 的服务器上。<br><a href="https://github.com/gohugoio/hugo/releases">前往Hugo</a></p><p>pelican：</p><p>是一个法国人用 python 写的用于生成静态页面的程序，支持：</p><p>1、博客文章和页面</p><p>2、使用外部服务 Disqus 实现的评论功能</p><p>3、支持主题</p><p>4、可对文章生成 PDF 文档</p><p>5、支持多语言发布文章</p><p>6、Atom/RSS feeds</p><p>7、代码着色</p><p>8、使用 LESS CSS (optional)</p><p>9、可导入 WordPress, Dotclear 或者 RSS feeds</p><p>10、集成外部功能 Twitter, Google Analytics, etc. (optional)<br><a href="https://github.com/getpelican/pelican">前往pelican</a></p><p>建站的框架很多，选择喜欢的风格即可。</p><h2 id="域名查询与购买"><a href="#域名查询与购买" class="headerlink" title="域名查询与购买"></a>域名查询与购买</h2><p>阿里云 万网：<a href="https://wanwang.aliyun.com/">前往查询</a></p>]]></content>
      
      
      <categories>
          
          <category> web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
